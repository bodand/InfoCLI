//// BSD 3-Clause License
//
// Copyright (c) 2020, bodand
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//
// Created by bodand on 2020-05-21.
//

// SHARED STUFF
#include <array>
template<int>
constexpr static auto Options = std::array{
       "a.out",
#include "data/${BENCHMARK_NUMBER}.input.txt"
       "--option-9999", "5"
};
template<int>
static int a{};
template<int>
static int b{};

#include <benchmark/benchmark.h>

// getopt_long /////////////////////////////////////////////////////////////////
#include <getopt.h>
#include <cstdio>
#include <cstring>

void _getopt_long(benchmark::State& state) {
    int argc = Options<0>.size();
    char** argv = const_cast<char**>(Options<1>.data());

    int opt_idx = 0;
    static option opts[] = { //&!off
           {"help",        no_argument,       0, 0},
#include "data/${BENCHMARK_NUMBER}.gnu.opt.txt"
           {"option-9999", required_argument, 0, 0},
           {0,             0,                 0, 0}
    }; //&!on
    static auto helps = std::array{
#include "data/${BENCHMARK_NUMBER}.gnu.help.txt"
           "more help -- 9999"
    };

    auto help = []() {
      for (std::size_t i = 0; i < std::size(helps); ++i) {
          printf("  %14s%s", opts[i].name, helps[i]);
      }
      std::exit(1);
    };

    auto handle = [&help, &opt_idx](auto argc, auto argv) {
      int opt;
      std::vector<std::string_view> pos_args;

      for (;;) {
          if (opt = getopt_long(argc, argv, "-h", opts, &opt_idx);
                 opt == -1) {
              break;
          }

          switch (opt) {
              case 0:
                  if (strcmp(opts[opt_idx].name, "help") == 0) {
                      help();
                  }
#include "data/${BENCHMARK_NUMBER}.gnu.check.txt"
                  if (strcmp(opts[opt_idx].name, "option-9999") == 0) {
                      b<0> = atoi(optarg);
                      break;
                  }
                  break;

              case 1:
                  pos_args.emplace_back(argv[opt_idx]);
                  break;

              case 'h':
                  help();

              default:
                  break;
          }
      }

      return pos_args;
    };

    for (auto _ : state) {
        auto ret = handle(argc, argv);
        benchmark::DoNotOptimize(ret);
    }
}


// Boost.ProgramOptions ////////////////////////////////////////////////////////
#include <boost/program_options.hpp>
namespace po = boost::program_options;

void _boost_program_options(benchmark::State& state) {
    po::options_description desc("opts");
    desc.add_options()
               ("help", "print help")
#include "data/${BENCHMARK_NUMBER}.boost.txt"
               ("option-9999", po::value<int>(&b<1>), "more help -- 9999");

    int argc = Options<1>.size();
    char** argv = const_cast<char**>(Options<1>.data());

    for (auto _ : state) {
        auto ret = po::parse_command_line(argc, argv, desc);
        benchmark::DoNotOptimize(ret);
    }
}

// cxxopts /////////////////////////////////////////////////////////////////////
#include <cxxopts.hpp>
namespace cxo = cxxopts;

void _cxxopts(benchmark::State& state) {
    cxo::Options opts("opts");
    opts.add_options()
               ("h,help", "print help")
#include "data/${BENCHMARK_NUMBER}.cxxopts.txt"
               ("option-9999", "some help -- 9999", cxo::value<int>(b<2>));

    int argc = Options<2>.size();
    char** argv = const_cast<char**>(Options<2>.data());

    for (auto _ : state) {
        auto ret = opts.parse(argc, argv);
        benchmark::DoNotOptimize(ret.arguments().size());
    }
}

// info CLI ////////////////////////////////////////////////////////////////////
#include <info/cli.hpp>
using namespace info::cli::literals;
namespace ic = info::cli;

void _info_cli(benchmark::State& state) {
    auto cli = ic::cli_parser::make(
#include "data/${BENCHMARK_NUMBER}.info.txt"
           "option-9999"_opt["more help -- 9999"_hlp]->*b<3>
    )();

    int argc = Options<3>.size();
    char** argv = const_cast<char**>(Options<3>.data());

    for (auto _ : state) {
        auto ret = cli(argc, argv);
        benchmark::DoNotOptimize(ret);
    }
}


BENCHMARK(_getopt_long);
BENCHMARK(_boost_program_options);
BENCHMARK(_cxxopts);
BENCHMARK(_info_cli);

